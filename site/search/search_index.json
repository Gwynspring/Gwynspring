{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#rescue-maze","title":"Rescue Maze","text":""},{"location":"#overview","title":"Overview","text":"<p>This repository contains the code and documentation for my diploma project at HTL Bulme. The goal of this project is to design and implement a robust sensor integration and communication system for a rescue robot. The system integrates multiple sensors, such as Time-of-Flight (ToF) sensors, the TCS34725 RGB module, and the L3GD20H gyroscope, using the I2C communication protocol.  </p> <p>Letter and color recognition is implemented using the OpenMV Cam H7.  Most of the tools used in this project come from the open-source community and can be built without purchasing additional software.  </p> <p>By sharing this project, I aim to contribute to the community. Feel free to copy, modify, and experiment with the code. If you encounter any issues, please open an issue, and I will work on fixing the bug.  </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Time-of-Flight (ToF) Distance Measurement: High-precision distance measurement using ToF sensors.  </li> <li>Gyroscope Data Acquisition: Integration of the L3GD20H gyroscope for angular velocity measurements, with customizable settings for sensitivity and motor control.  </li> <li>Custom I2C Addressing: Dynamic configuration of I2C addresses for multiple sensors on the same bus, ensuring seamless communication.  </li> <li>Multi-Pin I2C Implementation: Utilizing the SoftWire library to run I2C on different pins of the Arduino Mega.  </li> <li>Documentation &amp; Prototyping Tools: Includes documentation of the used equipment and helpful scripts.  </li> <li>AI-Based Letter Recognition: A custom-trained model using Edge Impulse for letter recognition.  </li> <li>Datasheets: Collection of datasheets for the sensors and microcontrollers used in the project.  </li> <li>Serial Communication: Implemented serial communication between the Arduino and OpenMV Cam.  </li> <li>PWM Control: Flexible functions for Pulse Width Modulation (PWM).  </li> </ul>"},{"location":"#motors","title":"Motors","text":"<p>Control of four DF Robot 6V DC motors with encoders and a PID control system.  </p> <p>Switching between driving modes:</p> <ul> <li>Gyroscope-based navigation </li> <li>ToF-based navigation </li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This project was developed as part of my diploma thesis at HTL Bulme Graz G\u00f6sting, with guidance and support from my teachers. Special thanks to the open-source community for providing the software and knowledge that made this project possible.</p>"},{"location":"appendix/ref/","title":"Resources and useful links","text":"<ul> <li> <p>https://www.ti.com/lit/an/sbaa565/sbaa565.pdf</p> </li> <li> <p>https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/ATmega640-1280-1281-2560-2561-Datasheet-DS40002211A.pdf</p> </li> <li> <p>Prescaler Konfiguration</p> </li> <li> <p>Nyquist-Frequenz</p> </li> <li> <p>MkDocs </p> </li> <li> <p>Material f\u00fcr MKDocs </p> </li> <li> <p>mkdocstrings</p> </li> <li> <p>PlatformIO</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Git</p> </li> <li> <p>Github</p> </li> <li> <p>Kaggle</p> </li> <li> <p>KiCad</p> </li> </ul>"},{"location":"experiment/i2cDebugging/","title":"I\u00b2C Kommunikation","text":""},{"location":"experiment/i2cDebugging/#1-aufgabenstellung","title":"1. Aufgabenstellung","text":"<ul> <li>Gewinnung des Messsignals</li> <li>Festlegung der Struktur der Messeinrichtung</li> <li>Bestimmung der Signalformen</li> <li>\u00dcbertragung und Verarbeitung der Messsignale</li> <li>Ausgabe und Darstellung der gewonnenen Informationen</li> </ul>"},{"location":"experiment/i2cDebugging/#2-theoretische-grundlagen","title":"2. Theoretische Grundlagen","text":"<p>I\u00b2C ist ein Kommunikationsprotokoll, das zwei Leitungen \u2013 Serial Data Line (SDA) und Serial Clock Line (SCL) \u2013 verwendet.  Das Protokoll erm\u00f6glicht die Kommunikation zwischen mehreren Ger\u00e4ten, bei der jedes Ger\u00e4t eine eindeutige Adresse hat.  Es unterst\u00fctzt die \u00dcbertragung von Daten in Form von Byte-Paketen.</p>"},{"location":"experiment/i2cDebugging/#geschwindigkeitsmodi","title":"Geschwindigkeitsmodi","text":"<p>I\u00b2C-Kommunikation kann in den folgenden drei Modi erfolgen:</p> <ul> <li>Standardmode (Sm): 100 kbit/s</li> <li>Fastmode (Fm): 400 kbit/s</li> <li>Fastmode Plus (Fm+): 1 Mbit/s</li> </ul> <p>Abb. 1.1: Gegen\u00fcberstellung der Geschwindigkeitsmodi</p> <p> Quelle: Wu, Joseph, 2022, S.3</p>"},{"location":"experiment/i2cDebugging/#aufbau-des-i2c-bus","title":"Aufbau des I\u00b2C-Bus","text":"<p>Abb. 1.2: Schematischer Aufbau eines I\u00b2C Bussystems</p> <p></p> <p>(vgl. ebd.,S.4, Figure 2-1)</p>"},{"location":"experiment/i2cDebugging/#scl-serial-clock","title":"SCL (Serial Clock)","text":"<p>Die SCL-Leitung ist f\u00fcr den Takt der Kommunikation verantwortlich und wird vom Master gesteuert. Sie gibt den Rhythmus f\u00fcr die Daten\u00fcbertragung vor.</p>"},{"location":"experiment/i2cDebugging/#sda-serial-data","title":"SDA (Serial Data)","text":"<p>Die SDA-Leitung \u00fcbertr\u00e4gt die eigentlichen Daten zwischen den Ger\u00e4ten. Ein Controller kann Ausgabewerte an einen DAC senden oder Daten von einem ADC empfangen.</p>"},{"location":"experiment/i2cDebugging/#halbduplex-vs-vollduplex","title":"Halbduplex vs. Vollduplex","text":"<p>I\u00b2C ist ein halbduplexes Kommunikationsprotokoll, bei dem Daten nur in eine Richtung gleichzeitig flie\u00dfen k\u00f6nnen. Im Gegensatz dazu ist SPI ein vollduplexes Protokoll, das gleichzeitige Daten\u00fcbertragungen in beide Richtungen erm\u00f6glicht.</p> <p>Vorteile von I\u00b2C:</p> <ul> <li>Geringer Verdrahtungsaufwand</li> <li>Weniger ben\u00f6tigte Pins am Mikrocontroller</li> </ul>"},{"location":"experiment/i2cDebugging/#i2c-adressierung-und-busstruktur","title":"I\u00b2C Adressierung und Busstruktur","text":"<p>Der I\u00b2C-Bus nutzt eine Master-Slave-Struktur, wobei der Master die Kommunikation initiiert und steuert. Jedes Ger\u00e4t auf dem Bus hat eine eindeutige Adresse, die es ihm erm\u00f6glicht, mit anderen Ger\u00e4ten zu kommunizieren. Die SDA- und SCL-Leitungen sind mit allen Ger\u00e4ten auf dem Bus \u00fcber Open-Drain-Verbindungen verbunden, was Pull-up-Widerst\u00e4nde erfordert.</p>"},{"location":"experiment/i2cDebugging/#i2c-start-und-stoppbedingungen","title":"I\u00b2C Start- und Stoppbedingungen","text":"<p>Die Kommunikation wird mit einer START-Bedingung eingeleitet, wobei der Master die SDA-Leitung auf Low und dann die SCL-Leitung auf Low zieht. Die Kommunikation endet mit einer STOP-Bedingung, bei der beide Leitungen auf High gesetzt werden, um den Bus freizugeben.</p> <p>Abb. 1.3: Start- und Stoppvorgang der Kommunikation</p> <p> (vgl. ebd.,S.7, Figure 3-1)</p>"},{"location":"experiment/i2cDebugging/#3-bauelementdaten","title":"3. Bauelementdaten","text":"<p>Verwendete Bauteile:</p> <ul> <li>2x VL53L0X</li> <li>2x VL53L1X</li> <li>3x VL6180</li> <li>2x TCS3472 RGB Sensor</li> <li>L3GD20H Gyrosensor</li> <li>OLED Display 0,96 Zoll</li> </ul>"},{"location":"experiment/i2cDebugging/#4-messung-mit-dem-oszilloskop","title":"4. Messung mit dem Oszilloskop","text":"<p>Abb. 2.3: Versuchsaufbau </p> <p>Abb. 2.4: Detailansicht der Messspitzen</p> <p></p> <p>Abb. 2.5: Ausschnitt einer Messung der I\u00b2C-Kommunikation mit dem Oszilloskop</p> <p></p>"},{"location":"experiment/i2cDebugging/#5-messergebnisse-und-programmierung","title":"5. Messergebnisse und Programmierung","text":""},{"location":"experiment/i2cDebugging/#pandas","title":"Pandas","text":"<p>Das Pandas-Framework wird verwendet, um die <code>.csv</code>-Datei zu importieren, die aus der PicoScope7-Software exportiert wurde. Diese Datei enth\u00e4lt 64 Buffer-Nummern und zeigt die Kommunikation zwischen dem Arduino Mega und den verwendeten Sensoren. Pandas erleichtert die Anzeige und Analyse der Daten.</p>"},{"location":"experiment/i2cDebugging/#seaborn","title":"Seaborn","text":"<p>F\u00fcr die Analyse und Visualisierung der Daten wurde Seaborn, eine auf Matplotlib basierende Python-Bibliothek, verwendet. Seaborn bietet eine benutzerfreundliche Schnittstelle f\u00fcr das Erstellen attraktiver und informativer statistischer Grafiken.</p> <p></p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# CSV-Datei laden\ndf = pd.read_csv(\"/path/to/your/file.csv\")\n\n# \u00dcberpr\u00fcfen auf fehlende Werte\nprint(df.isna())\nprint(df.dropna())\n\n# Farbschema festlegen\ncmap = plt.get_cmap('viridis')\n\n# Histogramm der I\u00b2C-Adressen\nsns.histplot(data=df, x=\"Address\", hue='Address', palette='Set1')\nplt.grid(True, axis='x', linestyle='')\nplt.xlabel(\"Adressen\")\nplt.ylabel(\"Anzahl der \u00dcbertragungen\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\n\n# Speichern und Anzeigen des Diagramms\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_Decoding\")\nplt.show()\n\n# Anzahl der Lese- und Schreibvorg\u00e4nge\nplt.title(\"Anzahl der Lese- und Schreibvorg\u00e4nge\")\nsns.barplot(data=df[\"R/W\"].value_counts(), palette=\"deep\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\nplt.ylabel(\"Anzahl der Vorg\u00e4nge\")\n\n# Speichern und Anzeigen des Diagramms\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_R_W\")\nplt.show()\n\n# Berechnung der Zeitdifferenz\ndf['Time'] = df[\"End Time\"] - df[\"Start Time\"]\nprint(df['Time'])\n\n# Gesamtdauer der Messung\nduration = df['Time'].sum()\nprint(f'L\u00e4nge der Messung: {duration * 1000} ms')\n</code></pre>"},{"location":"experiment/pwm/","title":"Timer/Counter0 f\u00fcr die Pulsweitenmodulation mit dem Atmega2560","text":""},{"location":"experiment/pwm/#1-ubersicht","title":"1. \u00dcbersicht","text":"<p>Der Timer/Counter0 ist ein 8-Bit-Z\u00e4hlermodul mit zwei unabh\u00e4ngigen Vergleichseinheiten und Unterst\u00fctzung f\u00fcr die Pulsweitenmodulation (PWM). Diese Funktion erm\u00f6glicht die pr\u00e4zise Steuerung eines generierten Signals. Das folgende Blockdiagramm illustriert den Ablauf:</p> <p>Abb. 1.1: Blockdiagramm  Quelle: ATmega Datenblatt, 2014, S.115, Figure 16-1</p>"},{"location":"experiment/pwm/#2-register-uberblick","title":"2. Register \u00dcberblick","text":"<p>Die wichtigsten Register sind:</p> <ul> <li>TCNT0 (Timer/Counter)</li> <li>OCR0A und OCR0B (Output Compare Register)</li> </ul> <p>Diese 8-Bit-Register k\u00f6nnen individuell programmiert werden. Interrupts werden \u00fcber das Timer Interrupt Mask Register (TIMSK0) konfiguriert.</p> <p>Der Timer/Counter kann mit dem internen Mikrokontroller-Takt oder einem externen Taktgeber am Pin T0 betrieben werden. Bei Nutzung des internen Takts kann der Prescaler im Register TCCR0B angepasst werden, um die Timer-Frequenz zu skalieren. Die Berechnung wird sp\u00e4ter genauer erl\u00e4utert.</p> <p>Die OCR0A- und OCR0B-Register werden fortlaufend mit dem Z\u00e4hlerwert verglichen. Das Ergebnis dieses Vergleichs kann zur Signalerzeugung genutzt werden.</p>"},{"location":"experiment/pwm/#3-detaillierte-registeranalyse-fur-pwm","title":"3. Detaillierte Registeranalyse f\u00fcr PWM","text":""},{"location":"experiment/pwm/#31-tccr0a","title":"3.1. TCCR0A","text":"<p>Im TCCR0A-Register wird das Bit WGM01 gesetzt, um den Timer in den Clear Timer on Compare Match (CTC)-Modus zu versetzen. In diesem Modus z\u00e4hlt der Timer bis zu einem definierten Wert und wird anschlie\u00dfend zur\u00fcckgesetzt.</p> <p>Abb. 3.1: TCCR0A  (vgl. ebd.,S.126)</p>"},{"location":"experiment/pwm/#32-tccr0b","title":"3.2. TCCR0B","text":"<p>Im TCCR0B-Register wird das Bit CS01 gesetzt, um den CPU-Takt mit einem Prescaler von 8 zu verwenden.</p> <p>Abb. 3.2: TCCR0B  (vgl. ebd.,S.129)</p>"},{"location":"experiment/pwm/#33-ocr0a","title":"3.3. OCR0A","text":""},{"location":"experiment/pwm/#331-funktion","title":"3.3.1. Funktion","text":"<p>Das OCR0A-Register enth\u00e4lt einen 8-Bit-Wert, der mit dem Z\u00e4hler verglichen wird. Bei \u00dcbereinstimmung kann ein Interrupt ausgel\u00f6st werden, der zur PWM genutzt wird. Mit einem Prescaler von 8 wird alle 100 \\(\u00b5s\\) ein Interrupt generiert.</p> <p>Abb. 3.3: OCR0A  (vgl. ebd.,S.130)</p>"},{"location":"experiment/pwm/#332-berechnung-des-vergleichswertes","title":"3.3.2. Berechnung des Vergleichswertes","text":"<p>Das Ziel ist eine PWM mit 20 \\(Hz\\) f\u00fcr Servomotoren. Die Timer-Frequenz ergibt sich aus dem CPU-Takt und dem Prescaler:</p> \\[ f_{\\text{timertick}} = \\frac{16 \\cdot 10^6 \\, \\text{Hz}}{8} = 2 \\cdot 10^6 \\, \\text{Hz} \\] <p>Ein Timerimpuls wird alle 0,1 \\(ms\\) ben\u00f6tigt:</p> \\[ \\text{ticks}(x) = f\\_{\\text{timertick}} \\cdot x = 2 \\cdot 10^6 \\, \\text{Hz} \\cdot (0.1 \\cdot 10^{-3}) \\, \\text{s} = 200 \\] <p>Der Vergleichswert ergibt sich zu:</p> \\[ OCR0A = \\text{ticks}(x) - 1 = 199 \\]"},{"location":"experiment/pwm/#34-timsk0","title":"3.4. TIMSK0","text":"<p>Im TIMSK0-Register wird das Bit OCIE0A gesetzt, um den Timer0-Interrupt bei einem Compare-Match zu aktivieren.</p> <p>Abb. 3.4: TIMSK0  (vgl. ebd.,S.131)</p>"},{"location":"experiment/pwm/#5-versuchsaufbau","title":"5. Versuchsaufbau","text":"<p>Abb. 5.1: Messung der Pulsweitenmodulation f\u00fcr einen Servomotor </p>"},{"location":"experiment/pwm/#4-grafische-darstellung-der-pwm","title":"4. Grafische Darstellung der PWM","text":"<p>Der modulierte Signalverlauf \u00fcber 3,5 \\(ms\\) zeigt unterschiedliche Pulsweiten, die zur Servomotorsteuerung genutzt werden.</p>"},{"location":"experiment/pwm/#positionen-des-servomotors","title":"Positionen des Servomotors:","text":"<ul> <li>0\u00b0: 500 \\(\u00b5s\\)</li> <li>90\u00b0: 1450 \\(\u00b5s\\)</li> <li>180\u00b0: 2400 \\(\u00b5s\\)</li> </ul> <p>Abb. 4.1: Signal mit 1ms Pulsweite </p> <p>Abb. 4.2: Signal mit 2ms Pulsweite </p>"},{"location":"experiment/pwm/#5-frequenzanalyse-des-pwm-signals","title":"5. Frequenzanalyse des PWM-Signals","text":""},{"location":"experiment/pwm/#51-sampling-frequenz-und-auflosung","title":"5.1. Sampling-Frequenz und Aufl\u00f6sung","text":"<ul> <li>Die Sampling-Frequenz \\(f_s = 3,13 MS/s\\) erf\u00fcllt das Nyquist-Theorem:   $$   f_s &gt; 2 \\cdot f_{\\text{signal}}   $$</li> </ul>"},{"location":"experiment/pwm/#52-spektrumverteilung","title":"5.2. Spektrumverteilung","text":"<ul> <li>Stark ged\u00e4mpft im h\u00f6heren Frequenzbereich (\\(&lt; -60 dB\\)).</li> </ul>"},{"location":"experiment/pwm/#53-charakteristische-frequenzkomponenten","title":"5.3. Charakteristische Frequenzkomponenten","text":"<ul> <li>Dominante Grundfrequenz sichtbar bei niedriger Frequenz.</li> </ul>"},{"location":"experiment/pwm/#54-rauschkomponenten","title":"5.4. Rauschkomponenten","text":"<ul> <li>Hohes Grundrauschen, besonders bei Frequenzen &gt; 0.5 MHz.</li> </ul> <p>Abb. 5.1 Analyse der Frequenzen </p>"},{"location":"experiment/pwm/#6-programmierung-der-pulsweitenmodulation","title":"6. Programmierung der Pulsweitenmodulation","text":"<pre><code>#include \"RS232.h\"\n#include \"ADU_ATMEGA2560 V21.h\"\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include &lt;util/delay.h&gt;\n#include &lt;Arduino.h&gt;\n\n#define SERVO_1_PIN PE5\n#define SERVO_1_DDR DDRE\n#define SERVO_1_PORT PORTE\n#define SERVO_2_PIN PG5\n#define SERVO_2_DDR DDRG\n#define SERVO_2_PORT PORTG\n\nvolatile uint8_t pulse_length_servo1 = 15;\nvolatile uint8_t pulse_length_servo2 = 15;\nvolatile bool move_to_180 = true;\n\nvoid setup()\n{\n    TCCR0A = (1 &lt;&lt; WGM01);\n    TCCR0B = (1 &lt;&lt; CS01);\n    OCR0A = 199;\n    TIMSK0 = (1 &lt;&lt; OCIE0A);\n\n    SERVO_1_DDR |= (1 &lt;&lt; SERVO_1_PIN);\n    SERVO_2_DDR |= (1 &lt;&lt; SERVO_2_PIN);\n\n    sei();\n\n    ADU_Init();\n    RS232_Init(RS232_NUR_EMPFANGEN);\n}\n\nvoid loop()\n{\n    if (Empfangen == 'u')\n    {\n        if (move_to_180)\n        {\n            pulse_length_servo1 = 24;\n            pulse_length_servo2 = 24;\n        }\n        else\n        {\n            pulse_length_servo1 = 5;\n            pulse_length_servo2 = 5;\n        }\n\n        move_to_180 = !move_to_180;\n        Empfangen = 0;\n    }\n}\n\nISR(TIMER0_COMPA_vect)\n{\n    static uint8_t counter = 0;\n\n    if (counter == 0)\n    {\n        SERVO_1_PORT |= (1 &lt;&lt; SERVO_1_PIN);\n        SERVO_2_PORT |= (1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    if (counter == pulse_length_servo1)\n    {\n        SERVO_1_PORT &amp;= ~(1 &lt;&lt; SERVO_1_PIN);\n    }\n    if (counter == pulse_length_servo2)\n    {\n        SERVO_2_PORT &amp;= ~(1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    counter++;\n    if (counter &gt;= 200)\n    {\n        counter = 0;\n    }\n}\n</code></pre>"},{"location":"hardware/components/","title":"Sensors, Actuators, and Measuring Devices Used","text":"Sensor / Actuator / Measuring Device Communication Function Additional Details Quantity Arduino Mega2560R3 I\u00b2C / RS232 Microcontroller 54 digital pins and 16 analog input pins. 1 VL53L0X I\u00b2C Distance sensor Range up to 2m 2 VL53L1X I\u00b2C Distance sensor Range up to 4m 2 VL6180 I\u00b2C Distance sensor Infrared, short range 4 TCS3472 I\u00b2C RGB color sensor Color recognition 2 L3GD20H I\u00b2C Gyroscope 3-axis gyroscope 1 OLED Display I\u00b2C Display 0.96-inch, 128x64 pixels 1 LM2596 I\u00b2C Voltage regulator 3A output 1 Picoscope 2205A Oscilloscope USB Communication measurement PWM, \\(I^2C\\) 1 OpenMV Cam H7 RS232 Letter recognition Communicates with Arduino Mega via RS232 2 SG92R Servo Motor GPIO Package ejection Controlled via PWM 2 FIT0522 DC Motor GPIO Robot propulsion PID controlled 4 TB6612FNG Motor Driver GPIO Motor control 1A output 2 Neopixel Ring 12 LED GPIO Status signaling 5.0V, 12x 18.5mA (max. 12x 55mA per module) 1 Limit Switch GPIO Collision protection Left and right front 2"},{"location":"hardware/cad/fusion/","title":"3D-Model","text":"<p>The robot was designed using Autodesk Fusion. I created STEP files from the PCBs in KiCad and then imported them into Fusion, making it much easier to design the robot. All the files can be found in the repository under CAD.</p> <p></p>"},{"location":"hardware/cad/pcb/","title":"PCB","text":"<p>The PCBs were designed using KiCad, and the schematics as well as the PCB files can be found in the repository under PCB. Because of the robust and flexible usage of the JST connection system, I tried to use as many JST connections as possible. The <code>Arduino Mega2560</code> sits on the backside of the PCB and can be mounted on the robot case.</p>"},{"location":"hardware/cad/pcb/#main-pcb","title":"Main PCB","text":""},{"location":"hardware/cad/pcb/#voltage-conversion-and-motor-drivers","title":"Voltage Conversion and Motor Drivers","text":"<p>For easier replacement and usage, the two <code>Adafruit TB6612FNG</code> motor drivers are mounted with pins instead of being soldered directly onto the PCB.</p> <p></p>"}]}